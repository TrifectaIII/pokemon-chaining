import {
    createAsyncThunk,
    createSlice,
    PayloadAction,
} from '@reduxjs/toolkit';

import {
    RootState,
} from './store';
import {
    fetchPokemonInfo,
    fetchEggGroupInfo,
    fetchGenderInfo,
    Pokemon,
    Categories,
} from '../api/pokemonAPI';

type Load = 'loading' | 'loaded' | 'failed' | 'unloaded';

// Slice of state for counter page
export interface PokemonState {
    load: Load
    startingPokemon: string
    endingPokemon: string
    pokemon: Pokemon[] | null
    eggGroups: Categories | null
    genders: Categories | null
}

const initialState: PokemonState = {
    load: 'unloaded',
    startingPokemon: '',
    endingPokemon: '',
    pokemon: null,
    eggGroups: null,
    genders: null,
};

export const fetchPokemonInfoAsync = createAsyncThunk(
    'pokemon/fetchPokemonInfo',
    async (): Promise<{
        pokemon: Pokemon[],
        eggGroups: Categories,
        genders: Categories,
    }> => {

        const res = await Promise.all([
            fetchPokemonInfo(),
            fetchEggGroupInfo(),
            fetchGenderInfo(),
        ]);
        // The value we return becomes the `fulfilled` action payload
        return {
            pokemon: res[0],
            eggGroups: res[1],
            genders: res[2],
        };

    },
);

export const pokemonSlice = createSlice({
    name: 'pokemon',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        setStarting: (state, action: PayloadAction<string>) => {

            state.startingPokemon = action.payload;

        },
        setEnding: (state, action: PayloadAction<string>) => {

            state.endingPokemon = action.payload;

        },
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {

        builder.
            addCase(fetchPokemonInfoAsync.pending, (state) => {

                state.load = 'loading';

            }).
            addCase(fetchPokemonInfoAsync.fulfilled, (state, {payload}) => {

                state.load = 'loaded';
                state.pokemon = payload.pokemon;
                state.eggGroups = payload.eggGroups;
                state.genders = payload.genders;

            }).
            addCase(fetchPokemonInfoAsync.rejected, (state) => {

                state.load = 'failed';

            });

    },
});

export const {setStarting, setEnding} = pokemonSlice.actions;

// selectors
export const selectLoad =
    (state: RootState): Load => state.pokemon.load;
export const selectPokemon =
    (state: RootState): Pokemon[] | null => state.pokemon.pokemon;
export const selectEggGroups =
    (state: RootState): Categories | null => state.pokemon.eggGroups;
export const selectGenders =
    (state: RootState): Categories | null => state.pokemon.genders;
export const selectStartingPokemon =
    (state: RootState): string => state.pokemon.startingPokemon;
export const selectEndingPokemon =
    (state: RootState): string => state.pokemon.endingPokemon;

export default pokemonSlice.reducer;
